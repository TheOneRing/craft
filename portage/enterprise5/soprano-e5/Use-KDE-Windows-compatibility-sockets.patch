From 94e6f6d2d86c55da1a7340afd1cece8750c022c8 Mon Sep 17 00:00:00 2001
From: Andre Heinecke <aheinecke@intevation.de>
Date: Sun, 6 May 2012 20:11:26 +0200
Subject: [PATCH] Use KDE-Windows compatibility sockets

    This removes all the Windows Specific code in the soprano
    client implementation by using the socket's provided by the
    kdewin library.

    Adds a new dependency to kdewin when building soprano for
    Windows.
---
 CMakeLists.txt                 |    3 ++
 client/CMakeLists.txt          |    2 +
 client/clientconnection.cpp    |   53 ------------------------
 client/clientconnection_p.h    |   37 -----------------
 client/localsocketclient.cpp   |   43 -------------------
 client/localsocketclient.h     |    3 --
 client/socket.h                |    4 --
 client/socketstream.cpp        |   16 --------
 cmake/modules/FindKDEWin.cmake |   89 ++++++++++++++++++++++++++++++++++++++++
 9 files changed, 94 insertions(+), 156 deletions(-)
 create mode 100644 cmake/modules/FindKDEWin.cmake

diff --git a/CMakeLists.txt b/CMakeLists.txt
index d42397a..417c612 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -97,6 +97,9 @@ else(WIN32)
 endif(WIN32)
 endif(NOT SOPRANO_DISABLE_VIRTUOSO_BACKEND)
 
+if(WIN32)
+   find_package(KDEWIN REQUIRED)
+endif(WIN32)
 
 ##################  setup variables  ################################
 if(REDLAND_FOUND)
diff --git a/client/CMakeLists.txt b/client/CMakeLists.txt
index c1fa916..794f814 100644
--- a/client/CMakeLists.txt
+++ b/client/CMakeLists.txt
@@ -11,6 +11,7 @@ include_directories(
   ${soprano_core_SOURCE_DIR}/vocabulary
   ${QT_INCLUDES}
   ${soprano_SOURCE_DIR}
+  ${KDEWIN_INCLUDES}
 )
 
 set(soprano_client_SRC
@@ -73,6 +74,7 @@ target_link_libraries(
   ${QT_QTCORE_LIBRARY}
   ${QT_QTNETWORK_LIBRARY}
   ${QT_QTXML_LIBRARY}
+  ${KDEWIN_LIBRARIES}
   soprano
 )
 if(BUILD_DBUS_SUPPORT)
diff --git a/client/clientconnection.cpp b/client/clientconnection.cpp
index 3565f4d..74da78c 100644
--- a/client/clientconnection.cpp
+++ b/client/clientconnection.cpp
@@ -45,67 +45,24 @@ namespace {
 }
 
 
-#ifdef Q_OS_WIN
-Soprano::Client::SocketHandler::SocketHandler( ClientConnectionPrivate* client, Socket* socket )
-    : QObject(),
-      m_client( client ),
-      m_socket( socket )
-{
-}
-
-
-Soprano::Client::SocketHandler::~SocketHandler()
-{
-    QMutexLocker lock( &m_client->socketMutex );
-    m_client->sockets.removeAll( m_socket );
-    delete m_socket;
-}
-#endif
-
 Soprano::Client::ClientConnection::ClientConnection( QObject* parent )
     : QObject( parent ),
       d( new ClientConnectionPrivate() )
 {
-#ifndef Q_OS_WIN
     d->socket = 0;
-#endif
 }
 
 
 Soprano::Client::ClientConnection::~ClientConnection()
 {
-#ifdef Q_OS_WIN
-    d->socketMutex.lock();
-    // the sockets need to be deleted in their respective threads.
-    // this is what d->socketStorage does. We only close them here.
-    // FIXME: QThreadStorage does NOT delete the local data in its destructor!
-    foreach( QIODevice* socket, d->sockets ) {
-        socket->close();
-    }
-    d->socketMutex.unlock();
-#else
     delete d->socket;
-#endif
     delete d;
 }
 
 
 Soprano::Socket *Soprano::Client::ClientConnection::getSocket()
 {
-#ifdef Q_OS_WIN
-    if ( isConnected() ) {
-        return d->socketStorage.localData()->socket();
-    }
-    else if ( Socket* socket = newConnection() ) {
-        d->socketMutex.lock();
-        SocketHandler* cleaner = new SocketHandler( d, socket );
-        d->sockets.append( socket );
-        d->socketMutex.unlock();
-        d->socketStorage.setLocalData( cleaner );
-    }
-#else
     return d->socket;
-#endif
 }
 
 
@@ -806,26 +763,16 @@ bool Soprano::Client::ClientConnection::checkProtocolVersion()
 
 bool Soprano::Client::ClientConnection::connect()
 {
-#ifndef Q_OS_WIN
     if(!d->socket) {
         d->socket = newConnection();
     }
-#endif
     return( getSocket() != 0 );
 }
 
 
 bool Soprano::Client::ClientConnection::isConnected()
 {
-#ifdef Q_OS_WIN
-    return ( d->socketStorage.hasLocalData() &&
-             isConnected( d->socketStorage.localData()->socket() ) );
-#else
     return( d->socket != 0 && d->socket->isConnected() );
-#endif
 }
 
 #include "clientconnection.moc"
-#ifdef Q_OS_WIN
-#include "clientconnection_p.moc"
-#endif
diff --git a/client/clientconnection_p.h b/client/clientconnection_p.h
index 003472f..9ff9b17 100644
--- a/client/clientconnection_p.h
+++ b/client/clientconnection_p.h
@@ -22,51 +22,14 @@
 #ifndef _SOPRANO_SERVER_CLIENT_CONNECTION_P_H_
 #define _SOPRANO_SERVER_CLIENT_CONNECTION_P_H_
 
-#include <QtCore/QMutex>
-#include <QtCore/QList>
-#include <QtCore/QThreadStorage>
-#include <QtCore/QIODevice>
 #include "socket.h"
 
-class QThread;
-
 namespace Soprano {
     namespace Client {
-#ifdef Q_OS_WIN
-        class ClientConnectionPrivate;
-
-        /**
-         * A simple wrapper class which makes sure that
-         * sockets are closed and deleted once their
-         * spawning thread goes down.
-         */
-        class SocketHandler : public QObject
-        {
-            Q_OBJECT
-
-        public:
-            SocketHandler( ClientConnectionPrivate*, QIODevice* socket );
-            ~SocketHandler();
-
-            QIODevice* socket() const { return m_socket; }
-            void close() { m_socket->close(); }
-
-        private:
-            ClientConnectionPrivate* m_client;
-            QIODevice* m_socket;
-        };
-#endif
-
         class ClientConnectionPrivate
         {
         public:
-#ifndef Q_OS_WIN
             Socket* socket;
-#else
-            QList<QIODevice*> sockets;
-            QMutex socketMutex;
-            QThreadStorage<Soprano::Client::SocketHandler*> socketStorage;
-#endif
         };
     }
 }
diff --git a/client/localsocketclient.cpp b/client/localsocketclient.cpp
index cea06bc..f3579ff 100644
--- a/client/localsocketclient.cpp
+++ b/client/localsocketclient.cpp
@@ -29,12 +29,6 @@
 #include <QtCore/QThread>
 #include <QtNetwork/QLocalSocket>
 
-#ifdef Q_OS_WIN
-Q_DECLARE_METATYPE( QLocalSocket::LocalSocketError )
-Q_DECLARE_METATYPE( QAbstractSocket::SocketError )
-Q_DECLARE_METATYPE( QAbstractSocket::SocketState )
-#endif
-
 namespace Soprano {
     namespace Client {
         class LocalSocketClientConnection : public ClientConnection
@@ -45,9 +39,6 @@ namespace Soprano {
 
         protected:
             Socket *newConnection();
-#ifdef Q_OS_WIN
-            bool isConnected( Socket* );
-#endif
 
         private:
             QString m_socketPath;
@@ -71,34 +62,16 @@ namespace Soprano {
                 path = QDir::homePath() + QLatin1String( "/.soprano/socket" );
             }
 
-#ifndef Q_OS_WIN
             LocalSocket* socket = new LocalSocket;
             if ( socket->open( path ) ) {
                 return socket;
             }
             else {
                 setError( socket->lastError() );
-#else
-            QLocalSocket* socket = new QLocalSocket;
-            socket->connectToServer( path, QIODevice::ReadWrite );
-            if ( socket->waitForConnected() ) {
-                QObject::connect( socket, SIGNAL( error( QLocalSocket::LocalSocketError ) ),
-                                  parent(), SLOT( _s_localSocketError( QLocalSocket::LocalSocketError ) ) );
-                return socket;
-            }
-            else {
-                setError( socket->errorString() );
-#endif
                 delete socket;
                 return 0;
             }
         }
-
-#ifdef Q_OS_WIN
-        bool LocalSocketClientConnection::isConnected( Socket *device ) {
-            return( device ? static_cast<QLocalSocket*>( device )->state() == QLocalSocket::ConnectedState : false );
-        }
-#endif
     }
 }
 
@@ -111,28 +84,12 @@ public:
     }
 
     LocalSocketClientConnection* connection;
-#ifdef Q_OS_WIN
-    void _s_localSocketError( QLocalSocket::LocalSocketError );
-#endif
 };
 
-#ifdef Q_OS_WIN
-void Soprano::Client::LocalSocketClient::Private::_s_localSocketError( QLocalSocket::LocalSocketError error )
-{
-    qDebug() << "local socket error:" << error;
-}
-#endif
-
-
 Soprano::Client::LocalSocketClient::LocalSocketClient( QObject* parent )
     : QObject( parent ),
       d( new Private() )
 {
-#ifdef Q_OS_WIN
-    qRegisterMetaType<QLocalSocket::LocalSocketError>();
-    qRegisterMetaType<QAbstractSocket::SocketError>();
-    qRegisterMetaType<QAbstractSocket::SocketState>();
-#endif
 }
 
 
diff --git a/client/localsocketclient.h b/client/localsocketclient.h
index a31c694..d97aed0 100644
--- a/client/localsocketclient.h
+++ b/client/localsocketclient.h
@@ -120,9 +120,6 @@ namespace Soprano {
         private:
             class Private;
             Private* const d;
-#ifdef Q_OS_WIN
-            Q_PRIVATE_SLOT( d, void _s_localSocketError( QLocalSocket::LocalSocketError ) )
-#endif
         };
     }
 }
diff --git a/client/socket.h b/client/socket.h
index 5cdc00b..f4a44fa 100644
--- a/client/socket.h
+++ b/client/socket.h
@@ -29,9 +29,6 @@
 typedef int SOCKET_HANDLE;
 
 namespace Soprano {
-#ifdef Q_OS_WIN
-    typedef QIODevice Socket;
-#else
     /**
      * A thread-safe socket without the QObject overhead of Qt's own socket
      * implementations.
@@ -97,7 +94,6 @@ namespace Soprano {
 
         QString m_path;
     };
-#endif
 }
 
 #endif
diff --git a/client/socketstream.cpp b/client/socketstream.cpp
index dfd8713..42645ad 100644
--- a/client/socketstream.cpp
+++ b/client/socketstream.cpp
@@ -33,17 +33,13 @@
 Soprano::SocketStream::SocketStream( Soprano::Socket* dev )
     : m_device( dev )
 {
-#ifndef Q_OS_WIN
     m_device->lock();
-#endif
 }
 
 
 Soprano::SocketStream::~SocketStream()
 {
-#ifndef Q_OS_WIN
     m_device->unlock();
-#endif
 }
 
 
@@ -60,11 +56,7 @@ bool Soprano::SocketStream::writeByteArray( const QByteArray& a )
         int x = qMin( 1024U, len-cnt );
         int r = m_device->write( a.data()+cnt, x );
         if ( r < 0 ) {
-#ifdef Q_OS_WIN
-            setError( Error::Error( QString( "Failed to write string after %1 of %2 bytes (%3)." ).arg( cnt ).arg( len ).arg( m_device->errorString() ) ) );
-#else
             setError(m_device->lastError());
-#endif
             return false;
         }
         cnt += r;
@@ -255,11 +247,7 @@ bool Soprano::SocketStream::read( char* data, qint64 size )
             setError( Error::Error( QString( "Failed to read after %1 of %2 bytes (%3)." )
                                     .arg( cnt )
                                     .arg( size )
-#ifdef Q_OS_WIN
-                                    .arg( m_device->errorString ) ) );
-#else
                                     .arg( m_device->lastError().message() ) ) );
-#endif
             return false;
         }
         else if ( r == 0 && size > 0 ) {
@@ -267,11 +255,7 @@ bool Soprano::SocketStream::read( char* data, qint64 size )
                 setError( Error::Error( QString( "Timeout when reading after %1 of %2 bytes (%3)." )
                                         .arg( cnt )
                                         .arg( size )
-#ifdef Q_OS_WIN
-                                        .arg( m_device->errorString ) ) );
-#else
                                         .arg( m_device->lastError().message() ) ) );
-#endif
                 return false;
             }
         }
diff --git a/cmake/modules/FindKDEWin.cmake b/cmake/modules/FindKDEWin.cmake
new file mode 100644
index 0000000..2559fe1
--- /dev/null
+++ b/cmake/modules/FindKDEWin.cmake
@@ -0,0 +1,89 @@
+# - Try to find the KDEWIN library
+# 
+# Once done this will define
+#
+#  KDEWIN_FOUND - system has KDEWIN
+#  KDEWIN_INCLUDES - the KDEWIN include directories
+#  KDEWIN_LIBRARIES - The libraries needed to use KDEWIN
+
+# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
+# Copyright (c) 2007-2009, Ralf Habacker, <ralf.habacker@freenet.de>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+if (WIN32)
+
+  if(WINCE)
+    FIND_PACKAGE(WCECOMPAT REQUIRED)
+  endif(WINCE)
+
+  if (NOT KDEWIN_LIBRARY)
+
+
+    find_path(KDEWIN_INCLUDE_DIR kdewin_export.h
+      ${KDE4_INCLUDE_DIR}
+      ${CMAKE_INCLUDE_PATH}
+      ${CMAKE_INSTALL_PREFIX}/include
+    )
+
+    # search for kdewin in the default install directory for applications (default of (n)make install)
+    FILE(TO_CMAKE_PATH "${CMAKE_LIBRARY_PATH}" _cmakeLibraryPathCmakeStyle)
+
+    string(TOLOWER "${CMAKE_BUILD_TYPE}" CMAKE_BUILD_TYPE_TOLOWER)
+    if (CMAKE_BUILD_TYPE_TOLOWER MATCHES debug)
+        set (LIBRARY_NAME kdewind)
+    else(CMAKE_BUILD_TYPE_TOLOWER MATCHES debug)
+        set (LIBRARY_NAME kdewin)
+    endif (CMAKE_BUILD_TYPE_TOLOWER MATCHES debug)
+
+    find_library(KDEWIN_LIBRARY
+      NAMES ${LIBRARY_NAME}
+      PATHS 
+        ${KDE4_LIB_DIR}
+        ${_cmakeLibraryPathCmakeStyle}
+        ${CMAKE_INSTALL_PREFIX}/lib
+      NO_SYSTEM_ENVIRONMENT_PATH
+    )
+  endif (NOT KDEWIN_LIBRARY)
+
+  if (KDEWIN_LIBRARY AND KDEWIN_INCLUDE_DIR)
+    set(KDEWIN_FOUND TRUE)
+    # add needed system libs
+    if(NOT WINCE)
+        set(KDEWIN_LIBRARIES ${KDEWIN_LIBRARY} user32 shell32 ws2_32 netapi32 userenv)
+    else(NOT WINCE)
+         set(KDEWIN_LIBRARIES ${KDEWIN_LIBRARY} ws2 ${WCECOMPAT_LIBRARIES})
+    endif(NOT WINCE)
+
+    if (MINGW)
+      #mingw compiler
+      set(KDEWIN_INCLUDES ${KDEWIN_INCLUDE_DIR} ${KDEWIN_INCLUDE_DIR}/mingw ${QT_INCLUDES})
+    else (MINGW)
+      # msvc compiler
+      # add the MS SDK include directory if available
+      file(TO_CMAKE_PATH "$ENV{MSSDK}" MSSDK_DIR)
+      if (WINCE)
+        set(KDEWIN_INCLUDES ${KDEWIN_INCLUDE_DIR} ${KDEWIN_INCLUDE_DIR}/msvc ${WCECOMPAT_INCLUDE_DIR} ${QT_INCLUDES} ${MSSDK_DIR})
+      else(WINCE)
+        set(KDEWIN_INCLUDES ${KDEWIN_INCLUDE_DIR} ${KDEWIN_INCLUDE_DIR}/msvc ${QT_INCLUDES} ${MSSDK_DIR})
+      endif(WINCE)
+    endif (MINGW)
+
+  endif (KDEWIN_LIBRARY AND KDEWIN_INCLUDE_DIR)
+  # required for configure
+  set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES} ${KDEWIN_INCLUDES})
+  set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${KDEWIN_LIBRARIES})
+
+  if (KDEWIN_FOUND)
+    if (NOT KDEWin_FIND_QUIETLY)
+      message(STATUS "Found KDEWin library: ${KDEWIN_LIBRARY}")
+    endif (NOT KDEWin_FIND_QUIETLY)
+
+  else (KDEWIN_FOUND)
+    if (KDEWin_FIND_REQUIRED)
+      message(FATAL_ERROR "Could NOT find KDEWin library\nPlease install it first")
+    endif (KDEWin_FIND_REQUIRED)
+  endif (KDEWIN_FOUND)
+endif (WIN32)
-- 
1.7.10

